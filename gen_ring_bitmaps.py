from pathlib import Path
import math

try:
    Import  # type: ignore
except NameError:
    # When running standalone (for testing), define a no-op Import
    def Import(name):  # type: ignore
        return None

env = Import("env")  # Provided by PlatformIO/SCons


def generate_ring_bitmaps(project_dir: Path,
                          out_path: Path,
                          width: int = 16,
                          height: int = 16,
                          steps: int = 48,
                          r_outer: float = 7.0,
                          r_inner: float = 4.0) -> bool:
    """Generate the ring bitmaps header.

    Returns True if the output file was created/updated, False if it was already up-to-date.
    The function avoids rewriting the file when content is unchanged to prevent unnecessary rebuilds.
    """
    out_path.parent.mkdir(parents=True, exist_ok=True)

    cx = (width - 1) / 2.0
    cy = (height - 1) / 2.0

    frames = []  # list of byte arrays per frame (index 0..steps-1)

    def pack_frame(p: float, outline_buf: bytearray):
        # p in [0..1]: fill fraction (0 => empty, 1 => full circle)
        # Fill direction: COUNTER-CLOCKWISE from 12 o'clock (flipped vs previous)
        start_deg = -90.0  # 12 o'clock reference
        end_deg = start_deg + p * 360.0
        # Normalize end angle into [0,360)
        def angle_deg(x, y):
            a = math.degrees(math.atan2(y, x))
            if a < 0:
                a += 360.0
            return a

        # XBM bit order: LSB is leftmost pixel
        row_bytes = (width + 7) // 8
        buf = bytearray(row_bytes * height)

        for y in range(height):
            for x in range(width):
                dx = (x + 0.5) - cx
                dy = (y + 0.5) - cy
                r = math.hypot(dx, dy)
                if not (r_inner < r <= r_outer):
                    continue
                ang = angle_deg(dx, dy)  # 0 at +X, increasing CCW
                # Convert to 12 o'clock CCW domain (flipped direction):
                # ang_ccw_from_12 = (ang_ccw - 90 + 360) % 360
                ang_ccw12 = (ang - 90.0) % 360.0

                # Sector test: from 0 to span degrees inclusive, CCW
                if p >= 1.0:
                    span_ccw = 360.0
                else:
                    span_ccw = (p * 360.0)
                in_sector = ang_ccw12 <= span_ccw if span_ccw > 0 else False

                if in_sector:
                    byte_index = y * row_bytes + (x // 8)
                    bit_mask = 1 << (x % 8)  # LSB-first
                    buf[byte_index] |= bit_mask
        # OR with outline
        for i in range(len(buf)):
            buf[i] |= outline_buf[i]
        return bytes(buf)

    # Precompute outline mask (full ring outline, no fill)
    row_bytes = (width + 7) // 8
    outline = bytearray(row_bytes * height)
    for y in range(height):
        for x in range(width):
            dx = (x + 0.5) - cx
            dy = (y + 0.5) - cy
            r = math.hypot(dx, dy)
            # Outline thickness approx 1 px
            if abs(r - r_outer) <= 0.5 or abs(r - r_inner) <= 0.5:
                byte_index = y * row_bytes + (x // 8)
                outline[byte_index] |= (1 << (x % 8))

    # Generate frames: levels 0..steps-1 (level 0 is empty + outline, level steps-1 is full + outline)
    denom = float(steps - 1) if steps > 1 else 1.0
    for i in range(0, steps):
        p = i / denom
        frames.append(pack_frame(p, outline))

    guard = "ZLKM_UI_RING16x16_48_H_"
    # Build content in-memory to allow write-on-change behavior
    lines = []
    lines.append("// Auto-generated by gen_ring_bitmaps.py. Do not edit.\n")
    lines.append("#pragma once\n\n")
    lines.append("#include <stdint.h>\n\n")
    lines.append("namespace zlkm { namespace ui { namespace assets {\n\n")
    lines.append("static constexpr uint8_t RING16_W = %d;\n" % width)
    lines.append("static constexpr uint8_t RING16_H = %d;\n" % height)
    lines.append("static constexpr uint8_t RING16_STEPS = %d;\n\n" % steps)

    bytes_per_frame = ((width + 7) // 8) * height
    lines.append("static const uint8_t RING16X16_48[%d][%d] = {\n" % (steps, bytes_per_frame))
    for idx, frame in enumerate(frames):
        lines.append("  { ")
        for b_i, b in enumerate(frame):
            lines.append("0x%02X" % b)
            if b_i != len(frame) - 1:
                lines.append(", ")
        lines.append(" }")
        if idx != len(frames) - 1:
            lines.append(",")
        lines.append("\n")
    lines.append("};\n\n")
    lines.append("inline const uint8_t* ring16x16_frame(uint8_t level) {\n")
    lines.append("  if (level >= RING16_STEPS) level = RING16_STEPS - 1;\n")
    lines.append("  return RING16X16_48[level];\n")
    lines.append("}\n\n")
    lines.append("}}} // namespace zlkm::ui::assets\n")

    content = "".join(lines)
    content_bytes = content.encode("utf-8")

    # Write only if changed
    if out_path.exists():
        try:
            existing = out_path.read_bytes()
        except Exception:
            existing = None
        if existing == content_bytes:
            return False  # up-to-date, no write

    out_path.write_bytes(content_bytes)
    return True


def _pre_build_action(source, target, env):
    project_dir = Path(env.subst("$PROJECT_DIR"))
    out_header = project_dir / "src" / "ui" / "assets" / "ring16x16_48.h"
    try:
        changed = generate_ring_bitmaps(project_dir, out_header,
                                        width=16, height=16, steps=48,
                                        r_outer=7.0, r_inner=4.0)
        if changed:
            print(f"[gen_ring_bitmaps] Generated/Updated {out_header}")
        else:
            print(f"[gen_ring_bitmaps] Up-to-date {out_header}")
    except Exception as ex:
        print(f"[gen_ring_bitmaps] ERROR: {ex}")
        raise


# Hook into PlatformIO build
if env is not None:
    env.AddPreAction("buildprog", _pre_build_action)
